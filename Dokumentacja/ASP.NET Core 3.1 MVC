<! ASP.NET Core 3.1 MVC - kurs z Udemy !>


!----------------------------------------
! Paczki NUGET
!----------------------------------------
Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation -> paczka odpowiedzialna za to, że po zapisaniu zmian w projekcie,
                                                    należy tylko odświeżyć przeglądarkę.
                                                    W pliku "Startup.cs" należy zmienić w serwisie wpis:
                                                    z "services.AddControllersWithViews();"
                                                    na "services.AddControllersWithViews().AddRazorRuntimeCompilation();"


1. Instalujemy paczkę: Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation
2. Dodajemy 3 nowe projekty typu: "Class library" i kasujemy z każdego projektu pliki "Class1.cs"
  - Ksiegarnia.DataAccess
  - Ksiegarnia.Models
  - Ksiegarnia.Utility
4. Przenosimy z projektu "Ksiegarnia" katalog "Data" do projektu "Ksiegarnia.DataAccess"
5. W projekcie "Ksiegarnia.DataAccess" instalujemy paczki: 
  - Microsoft.EntityFrameworkCore.Relational
  - Microsoft.EntityFrameworkCore.SqlServer -> użyj lokalnej wersji...  
  - Microsoft.AspNetCore.Identity.EntityFrameworkCore -> użyj lokalnej wersji...  
6. W projekcie "Ksiegarnia.DataAccess" usuwamy wszystkie pliki w katalogu: "~\Data\Migrations\"
7. W projekcie "Ksiegarnia.DataAccess" w pliku "ApplicationDbContext.cs" zmieniam namespace na: 
  - Ksiegarnia.DataAccess.Data
8. W projekcie "Ksiegarnia" w pliku "~\Startup.cs" usuwam "using Ksiegarnia.Data;" i dodajemy 
   "using Ksiegarnia.DataAccess.Data;".
9. Przenosimy z projektu "Ksiegarnia" plik "~\Models\ErrorViewModel.cs" do projektu "Ksiegarnia.Models"
10. W projekcie "Ksiegarnia" usuwam katalog "~\Models"
11. W projekcie "Ksiegarnia.Models" dodaje katalog "~\ViewModels" i przenoszę do niego plik "~\ErrorViewModel.cs"
12. W projekcie "Ksiegarnia.Models" w pliku "~\ViewModels\ErrorViewModel.cs" zmieniam namespace na: 
  - Ksiegarnia.Models.ViewModels
13. W projekcie "Ksiegarnia" w pliku "~\Controllers\HomeController.cs" usuwam "using Ksiegarnia.Models;" 
    i naprawiam brakujący namespace w "ErrorViewModel".
14. W projekcie "Ksiegarnia" w pliku "~\Views\Shared\_ViewImports.cshtml" usuwam "@using Ksiegarnia.Models;" 
    i dodajemy "@using Ksiegarnia.Models.ViewModels;".
15. W projekcie "Ksiegarnia" w pliku "~\Views\Shared\Error.cshtml" dodaje "@using Ksiegarnia.Models.ViewModels;".
16. W projekcie "Ksiegarnia.Utility" dodaje klase "~\SD.cs" i zmieniam ją na "public static"
17. W projekcie "Ksiegarnia" dodaje referencje do:
  - Ksiegarnia.DataAccess
  - Ksiegarnia.Models
  - Ksiegarnia.Utility
18. W projekcie "Ksiegarnia.DataAccess" dodaje referencje do:
  - Ksiegarnia.Models
  - Ksiegarnia.Utility
19. W projekcie "Ksiegarnia" dodaje Area "Customer"
20. W projekcie "Ksiegarnia" w pliku "~\Startup.cs" zmieniam ENDPOINT z "pattern: "{controller=Home}/{action=Index}/{id?}");" na
    "pattern: "{area=Customer}/{controller=Home}/{action=Index}/{id?}");"
21. W projekcie "Ksiegarnia" w usuwam katalogi:
   - "~\Areas\Customer\Data" 
   - "~\Areas\Customer\Models" 
22. W projekcie "Ksiegarnia" przenoszę plik "~\HomeController.cs" do katalogu "~\Areas\Customer\Controllers\"
23. W projekcie "Ksiegarnia" w pliku "~\Areas\Customer\Controllers\HomeController.cs" dodaje za namespace Area:
   - "[Area("Customer")]"
24. W projekcie "Ksiegarnia" przenoszę katalog "~\Views\Home" do "~\Areas\Customer\Views"
25. W projekcie "Ksiegarnia" w pliku "~\Areas\Customer\Controllers\HomeController.cs" zmieniam namespace na: 
  - Ksiegarnia.Areas.Customer.Controllers
26. W projekcie "Ksiegarnia" kopiuje pliki:
  - "~\Views\_ViewImports.cshtml"
  - "~\Views\_ViewStart.cshtml"
    do katalogu:
  - "~\Areas\Customer\Views"
27. W projekcie "Ksiegarnia" edytuje plik "~\Areas\Customer\Views\_ViewStart.cshtml" i zmieniam wpis "Layout" z
   "Layout = "_Layout";" na "Layout = "~/Views/Shared/_Layout.cshtml";"
28. W projekcie "Ksiegarnia" dodaje Area "Admin"
29. W projekcie "Ksiegarnia" w usuwam katalogi:
   - "~\Areas\Admin\Data" 
   - "~\Areas\Admin\Models" 
30. W projekcie "Ksiegarnia" kopiuje pliki:
  - "~\Areas\Customer\Views\_ViewImports.cshtml"
  - "~\Areas\Customer\Views\_ViewStart.cshtml"
    do katalogu:
  - "~\Areas\Admin\Views"
31. W projekcie "Ksiegarnia" usuwam katalog:
  - "~\Controllers"
32. W projekcie "Ksiegarnia" usuwam plik:
  - "~\ScaffoldingReadMe.txt"
33. Ze strony https://bootswatch.com/ wybieram wygląd, który mnie interesuje i nadpisuje styll css Bootstrapa
    w katalogu projekcie "Ksiegarnia":
  - "~\wwwroot\lib\bootstrap\dist\css\bootstrap.css"
34. W projekcie "Ksiegarnia" edytuje plik "~\Views\Shared/_Layout.cshtml" zmieniam styl z "bootstrap.min.css" na 
    "bootstrap.css"
35. Ze strony https://jqueryui.com/datepicker/ pobieram style/skrypty i wypakowuje je w katalogu "~\wwwroot\lib\"
36. Ze strony https://datatables.net/ pobieram style/skrypty i wypakowuje je w katalogu "~\wwwroot\lib\"
37. Ze strony https://sweetalert.js.org/guides/ pobieram style/skrypty i wypakowuje je w katalogu "~\wwwroot\lib\"
38. Ze strony https://fontawesome.com/ pobieram style/skrypty i wypakowuje je w katalogu "~\wwwroot\lib\"
39. Ze strony https://codeseven.github.io/toastr/ pobieram style/skrypty i wypakowuje je w katalogu "~\wwwroot\lib\"
40. W projekcie "Ksiegarnia" w pliku "~\Views/Shared/_Layout.cshtml" dodaje:
    CSS:
	"<link rel="stylesheet" href="~/lib/DataTables/dataTables.min.css" />
    <link rel="stylesheet" href="~/lib/jquery-ui/jquery-ui.min.css" />
    <link rel="stylesheet" href="~/lib/CodeSeven-toastr/build/toastr.min.css" />"
	Java script
	"<script src="~/lib/jquery-ui/jquery-ui.min.js"></script>
    <script src="~/lib/DataTables/datatables.min.js"></script>
    <script type="text/javascript" src="~/lib/CodeSeven-toastr/build/toastr.min.js"></script>
    <script src="~/lib/sweetalert/sweetalert.min.js"></script>
    <script src="~/lib/fontawesome-free/js/all.js"></script>"
41. W projekcie "Ksiegarnia" w pliku "~\appsettings.json" sprawdzam/edytuje połączenie z bazą danych MS SQL
42. W projekcie "Ksiegarnia.DataAccess" otwieram Package Manager Console i dodaje nową migracje ( w konsoli musi być wybrane w
    polu "Default project: Ksiegarnia.DataAccess" ):
    "add-migration FirstInit"
43. W projekcie "Ksiegarnia.DataAccess" otwieram Package Manager Console i aktualizuje bazę danych zgodnie z migracją ( w konsoli musi być wybrane w
    polu "Default project: Ksiegarnia.DataAccess" ):
    "update-database"
44. W project "Ksiegarnia" w pliku "~\Views\Shared/_Layout.cshtml" dodaje do NAVBARU dodatkowe menu typu DROPDOWN
    "<li class="nav-item dropdown">
		<a class="nav-link dropdown-toggle text-light " href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
			Dropdown
		</a>
		<div class="dropdown-menu" aria-labelledby="navbarDropdown">
			<a class="dropdown-item" href="#">Action</a>
			<a class="dropdown-item" href="#">Another action</a>
			<div class="dropdown-divider"></div>
			<a class="dropdown-item" href="#">Something else here</a>
		</div>
	</li>"
45. W projekcie "Ksiegarnia.Models" dodaje nową klase "~\Kategoria.cs" a w nim model jako tabela:
    "public class Kategoria
    {
        [Key]
        public int Id { get; set; }
        
        [Display(Name="Nazwa Kategorii")]
        [Required]
        [MaxLength(50)]
        public string Nazwa { get; set; }

    }"
46. W projekcie "Kategoria.DataAccess" edytuje plik "~\Data\ApplicationDbContext.cs" i dodaje wpis o nowej tabeli:
    "        // Dodaje wpis aby Entity wiedział o nowym modelu => Kategoria
        public DbSet<Kategoria> Kategorie { get; set; }"
47. W projekcie "Ksiegarnia.DataAccess" otwieram Package Manager Console i dodaje nową migracje ( w konsoli musi być wybrane w
    polu "Default project: Ksiegarnia.DataAccess" ):
    "add-migration DodajeKategorieDoBazy"
48. W projekcie "Ksiegarnia.DataAccess" otwieram Package Manager Console i aktualizuje bazę danych zgodnie z migracją ( w konsoli musi być wybrane w
    polu "Default project: Ksiegarnia.DataAccess" ):
    "update-database"
49. W projekcie "Ksiegarnia.DataAccess" tworzę katalog "~\Repository"
50. W projekcie "Ksiegarnia.DataAccess" tworzę katalog "~\Repository\IRepository"
51. W projekcie "Ksiegarnia.DataAccess" w katalogu "~Repository\IRepository\" dodaje nowy INTERFACE "IRepository.cs" i modyfikuje ten plik
    "public interface IRepository<T> where T:class
    {
        T Get(int id);

        IEnumerable<T> GetAll(
            Expression<Func<T, bool>> filter = null,
            Func<IQueryable<T>, IOrderedQueryable<T>> orderBy = null,
            string includeProperties = null
            );

        T GetFirstOrDefault(
            Expression<Func<T, bool>> filter = null,
            string includeProperties = null
            );

        void Add(T entity);

        void Remove(int id);

        void Remove(T entity);

        void RemoveRange(IEnumerable<T> entity);

    }"
52. W projekcie "Ksiegarnia.DataAccess" w katalogu "~Repository\" dodaje nową CLASSę "Repository.cs" i modyfikuje ten plik
    "public class Repository<T> : IRepository<T> where T : class
    {

        //private readonly DbContext _db;
        private readonly ApplicationDbContext _db;
        internal DbSet<T> dbSet;

        public Repository(ApplicationDbContext db)
        {
            _db = db;
            this.dbSet = _db.Set<T>();
        }

        public void Add(T entity)
        {
            dbSet.Add(entity);
        }

        public T Get(int id)
        {
            return dbSet.Find(id);
        }

        public IEnumerable<T> GetAll(Expression<Func<T, bool>> filter = null, Func<IQueryable<T>, IOrderedQueryable<T>> orderBy = null, string includeProperties = null)
        {
            IQueryable<T> query = dbSet;
            
            if(filter != null)
            {
                query = query.Where(filter);
            }

            if(includeProperties != null)
            {
                foreach (var includeProp in includeProperties.Split(new char[] {','},
                    StringSplitOptions.RemoveEmptyEntries))
                {
                    query = query.Include(includeProp);
                }
            }

            if(orderBy != null)
            {
                return orderBy(query).ToList();
            }
            return query.ToList();
        }

        public T GetFirstOrDefault(Expression<Func<T, bool>> filter = null, string includeProperties = null)
        {
            IQueryable<T> query = dbSet;

            if (filter != null)
            {
                query = query.Where(filter);
            }

            if (includeProperties != null)
            {
                foreach (var includeProp in includeProperties.Split(new char[] { ',' },
                    StringSplitOptions.RemoveEmptyEntries))
                {
                    query = query.Include(includeProp);
                }
            }
             
            return query.FirstOrDefault();
        }

        public void Remove(int id)
        {
            T entity = dbSet.Find(id);
            Remove(entity);
        }

        public void Remove(T entity)
        {
            dbSet.Remove(entity);
        }

        public void RemoveRange(IEnumerable<T> entity)
        {
            dbSet.RemoveRange(entity);
        }
    }"
53. W projekcie "Ksiegarnia.DataAccess" w katalogu "~Repository\IRepository\" dodaje nowy INTERFACE "ICategoryRepository.cs" i modyfikuje ten plik
    "public interface ICategoryRepository : IRepository<Kategoria>
    {
        void Update(Kategoria kategoria);
    }"
54. W projekcie "Ksiegarnia.DataAccess" w katalogu "~Repository\" dodaje nową CLASSę "CategoryRepository.cs" i modyfikuje ten plik
    " public class CategoryRepository : Repository<Kategoria>, ICategoryRepository
    {
        //private readonly DbContext _db;
        private readonly ApplicationDbContext _db;

        public CategoryRepository(ApplicationDbContext db) : base(db)
        {
            _db = db;
        }

        public void Update(Kategoria kategoria)
        {
            var objFormDb = _db.Kategorie.FirstOrDefault(s => s.Id == kategoria.Id);
            if(objFormDb != null)
            {
                objFormDb.Nazwa = kategoria.Nazwa;
                _db.SaveChanges();
            }

        }
    }"
55. W projekcie "Kategoria.DataAccess" instaluje paczkę NUGET "Dapper"
56. W projekcie "Ksiegarnia.DataAccess" w katalogu "~Repository\IRepository\" dodaje nowy INTERFACE "ISP_Call.cs" i modyfikuje ten plik
    "public interface ISP_Call :IDisposable
    {
        // zwraca INT lub BOOL
        T Single<T>(string procedureName, DynamicParameters param = null);

        void Execute(string procedureName, DynamicParameters param = null);

        // Zwraca cały wiersz
        T OneRecord<T>(string procedureName, DynamicParameters param = null);
    
        IEnumerable<T> List<T>(string procedureName, DynamicParameters param = null);

        // zwraca dwie tabele
        Tuple<IEnumerable<T1>, IEnumerable<T2>> List<T1,T2>(string procedureName, DynamicParameters param = null);

    }"
57. W projekcie "Ksiegarnia.DataAccess" w katalogu "~Repository\" dodaje nową CLASSę "SP_Call.cs" i modyfikuje ten plik
    "public class SP_Call : ISP_Call
    {
        //private readonly DbContext _db;
        private readonly ApplicationDbContext _db;
        private static string ConnectionString = "";

        public SP_Call(ApplicationDbContext db)
        {
            _db = db;
            ConnectionString = db.Database.GetDbConnection().ConnectionString;
        }

        public void Dispose()
        {
            _db.Dispose();
        }

        public void Execute(string procedureName, DynamicParameters param = null)
        {
            using (SqlConnection sqlConnection = new SqlConnection(ConnectionString))
            {
                sqlConnection.Open();
                sqlConnection.Execute(procedureName, param, commandType: System.Data.CommandType.StoredProcedure);
            }
        }

        public IEnumerable<T> List<T>(string procedureName, DynamicParameters param = null)
        {
            using (SqlConnection sqlConnection = new SqlConnection(ConnectionString))
            {
                sqlConnection.Open();
                return sqlConnection.Query<T>(procedureName, param, commandType: System.Data.CommandType.StoredProcedure);
            }
        }

        public Tuple<IEnumerable<T1>, IEnumerable<T2>> List<T1, T2>(string procedureName, DynamicParameters param = null)
        {
            using (SqlConnection sqlConnection = new SqlConnection(ConnectionString))
            {
                sqlConnection.Open();
                var result = SqlMapper.QueryMultiple(sqlConnection, procedureName, param, commandType: System.Data.CommandType.StoredProcedure);
                var item1 = result.Read<T1>().ToList();
                var item2 = result.Read<T2>().ToList();
               
                if(item1 != null && item2 != null)
                {
                    return new Tuple<IEnumerable<T1>, IEnumerable<T2>>(item1, item2);
                }
            }
            return new Tuple<IEnumerable<T1>, IEnumerable<T2>>(new List<T1>(), new List<T2>());
        }

        public T OneRecord<T>(string procedureName, DynamicParameters param = null)
        {
            using (SqlConnection sqlConnection = new SqlConnection(ConnectionString))
            {
                sqlConnection.Open();
                var value = sqlConnection.Query<T>(procedureName, param, commandType: System.Data.CommandType.StoredProcedure);
                return (T)Convert.ChangeType(value.FirstOrDefault(),typeof(T));
            }
        }

        public T Single<T>(string procedureName, DynamicParameters param = null)
        {
            using (SqlConnection sqlConnection = new SqlConnection(ConnectionString))
            {
                sqlConnection.Open();
                return (T)Convert.ChangeType(sqlConnection.ExecuteScalar<T>(procedureName, param, commandType: System.Data.CommandType.StoredProcedure), typeof(T));
            }
        }
    }"
58. W projekcie "Ksiegarnia.DataAccess" w katalogu "~Repository\IRepository\" dodaje nowy INTERFACE "IUnitOfWork.cs" i modyfikuje ten plik
    "public interface IUnitOfWork : IDisposable
    {
        ICategoryRepository Category { get; }

        ISP_Call SP_Call { get; }
    }"
59. W projekcie "Ksiegarnia.DataAccess" w katalogu "~Repository\" dodaje nową CLASSę "UnitOfWork.cs" i modyfikuje ten plik
    "public class UnitOfWork : IUnitOfWork
    {
        private readonly ApplicationDbContext _db;

        public UnitOfWork(ApplicationDbContext db)
        {
            _db = db;
            Category = new CategoryRepository(_db);
            SP_Call = new SP_Call(_db);
        }

        public ICategoryRepository Category { get; private set; }

        public ISP_Call SP_Call { get; private set; }

        public void Dispose()
        {
            _db.Dispose();
        }

        public void Save()
        {
            _db.SaveChanges();
        }
    }"
60. W projekcie "Ksiegarnia" edytuje plik "~\Startup.cs" w którym dodaje nowy serwis:
    "services.AddScoped<IUnitOfWork, UnitOfWork>();" 
61. W projekcie "Ksiegarnia" tworzę katalog jeśli nie ma "~\Areas\Admin\Controllers"
62. TESTOWO - DO POMINIĘCIA 
    W projekcie "Ksiegarnia" w Areas Admin dodaje nowy kontroller "MVC Controller with views, using Entity Framework"
	i wypełniam pola w formularzu:
	- Model class: "Kategoria (Ksiegarnia.Models)"
	- Data context class: "ApplicationDbContext (Ksiegarnia.DataAccess.Data)"
	- Use a layout page: "~/Views/Shared/_Layout.cshtml"
63. TESTOWO - DO POMINIĘCIA 
    W projekcie "Ksiegarnia" edytuje plik "~\Views\Shared/_Layout.cshtml" i dodaje nowy NAVBAR LINK:
	"<li class="nav-item">
		<a class="nav-link text-light" asp-area="Admin" asp-controller="Kategorias" asp-action="Index">Kategorie</a>
	</li>"